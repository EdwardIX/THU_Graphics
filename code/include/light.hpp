#ifndef LIGHT_H
#define LIGHT_H

#include <Vector3f.h>
#include "object3d.hpp"
#include "ray.hpp"

class Light {
public:
    Light() = delete;
    Light(const Vector3f &e):emission(e){}
    virtual ~Light() = default;

    // virtual void getIllumination(const Vector3f &p, Vector3f &dir, Vector3f &col) const = 0;
    virtual Ray getPhoton(Vector3f &col) const = 0;
    virtual bool intersect(const Ray &r, float tmin, float &thit, Vector3f &col) const = 0;

protected: 
    Vector3f emission; // used only in Photon Emitting...
};


class DirectionalLight : public Light {
public:
    DirectionalLight() = delete;

    DirectionalLight(const Vector3f &d, const Vector3f &c): Light(50), direction(d.normalized()), color(c) {}

    ~DirectionalLight() override = default;

    ///@param p unsed in this function
    ///@param distanceToLight not well defined because it's not a point light
    void getIllumination(const Vector3f &p, Vector3f &dir, Vector3f &col) const {
        // the direction to the light is the opposite of the
        // direction of the directional light source
        dir = -direction;
        col = color;
    }

    Ray getPhoton(Vector3f &col) const override {
        // raise("Photon generated by Directional Light: Not Well Defined", false);
        col = color * emission;
        return Ray(Vector3f(rand_range(-10, 10), rand_range(-10, 10), rand_range(-10, 10)) - 100 * direction, direction);
    }

    bool intersect(const Ray &r, float tmin, float &thit, Vector3f &col) const {return false;}

private:

    Vector3f direction;
    Vector3f color;

};

class PointLight : public Light {
public:
    PointLight() = delete;

    PointLight(const Vector3f &p, const Vector3f &c): Light(500), position(p), color(c) {}

    ~PointLight() override = default;

    void getIllumination(const Vector3f &p, Vector3f &dir, Vector3f &col) const {
        // the direction to the light is the opposite of the
        // direction of the directional light source
        dir = (position - p);
        dir = dir / dir.length();
        col = color;
    }

    Ray getPhoton(Vector3f &col) const override {
        col = color * emission;
        return Ray(position, rand_sphere());
    }

    bool intersect(const Ray &r, float tmin, float &thit, Vector3f &col) const {return false;}

private:

    Vector3f position;
    Vector3f color;

};

class DiskLight : public Light {
public:
    DiskLight() = delete;
    DiskLight(const Vector3f &p, const Vector3f &e, const Vector3f &d, const Vector3f &c, float r):
        Light(e), position(p), direction(d.normalized()), color(c), radius(r) {
        do {
            xaxis = rand_sphere();
            yaxis = Vector3f::cross(xaxis, direction);
        }
        while(!O(yaxis.length()));
        yaxis.normalize();
        xaxis = Vector3f::cross(yaxis, direction);
    }

    Ray getPhoton(Vector3f &col) const override {
        col = color * (pi * radius * radius) * emission;
        Vector2f p = rand_circle();
        Vector3f o = position + radius * (xaxis * p[0] + yaxis * p[1]);
        Vector3f d = rand_sphere();
        float dot = Vector3f::dot(d, direction);
        if(dot < 0) d += 2*dot * direction;
        return Ray(o, d);
    }

    bool intersect(const Ray &r, float tmin, float &thit, Vector3f &col) const {
        // solve dot(r.O + r.D * t - position, direction) = 0
        float dot = Vector3f::dot(r.getDirection(), direction);
        if(!O(dot)) return false; // parallel
        thit = Vector3f::dot(r.getOrigin() - position, direction) / (-dot);
        if(thit < tmin || (r.pointAtParameter(thit) - position).squaredLength() >= radius * radius) 
            return false;
        col = color;
        return true;
    }

private:
    Vector3f position;
    Vector3f direction;
    Vector3f color;
    float radius;
    Vector3f xaxis, yaxis;
};

#endif // LIGHT_H
